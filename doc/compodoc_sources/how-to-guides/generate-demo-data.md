# How to generate demo data

If the app is run in the "useTemporaryDatabase" mode, realistic demo data is generated on each startup.

This Guide walks you through the steps to add data to this demo mode for your own Entity type.

## The Basics

1. Create a service that `extends DemoDataGenerator`.
1. Make sure you call `super()` in your constructor to execute the parent class' constructor.
1. Implement the `generateEntities(): Entity[]` method so that it returns an array of demo entities.
   - Try to create objects that are similar to real data. That will make it more useful during for testing and demo.
   - The most simple implementation could be to return an array of a few hard-coded instances.
1. To actually make the DemoDataModule generate your demo entities you need to add your service to its config.
   In the AppModule (or wherever you import the DemoDataModule) add your service provider:
   _ e.g. `DemoDataModule.forRoot([{ provide: DemoUserGeneratorService, useClass: DemoUserGeneratorService }])`
   _ When the DemoDataModule is loaded your generator is then also triggered.
1. Change your `config.json` and set `database.useTemporaryDatabase: true` to start the app with in demo mode
   and get your data generated on startup.

## Creating realistic, random data

Your generator service is a standard Angular Service that can become as complex as you need it to be.

- You can import our (customized) [faker.js](https://github.com/marak/Faker.js/)
  to easily generate realistic property values like names or dates.
  _ import `import {faker} from '../demo-data/faker';` (Faker is not an Angular service just a simple JavaScript module)
  _ use `child.name = faker.name.firstName() + ' ' + faker.name.lastName()` for example to generate realistic random names

- You can use Angular's dependency injection to inject any other services that you may rely on to generate meaningful demo data.
  This way you can also inject other DemoDataGenerators if you need to generate entities related to other types of entities.
  _ inject `demoChildren: DemoChildGenerator` in your constructor
  _ use `this.demoChildren.entities` to access all demo child entities that have been generated by the DemoChildGenerator \* generate your demo entities relating to the demo child entities as needed

## Making the generator configurable

If you want to make your generator more flexible, an important step is to receive some configuration.
This can be passed into your service through dependency injection as well.

(1.) Create a simple class to hold your config.
For example:

```
export class DemoChildConfig {
  count: number;
}
```

_Use a real class and not an interface for this.
Interfaces only exist in TypeScript before transpilation to Javascript and are not available during runtime,
therefore an interface cannot be used as a provider key for Angular dependency injection._

(2.) Add your config class to the constructor of your service to make it available within your generator:

```
  constructor(public config: DemoChildConfig) {
    super();
  }
```

(3.) Add a static method called `provider()` to your service class.
The provider method will accept an instance of your config class and return a array of Angular providers.
This makes it much easier to register your service together with its config.
(Our pattern for this is inspired by the `forRoot()` pattern of Angular Modules.)

```
  /**
   * This function returns a provider object to be used in an Angular Module configuration:
   *   `providers: [DemoUserProvider.provider({count: 150})]`
   * @param config The configuration specifying the number of entities the service should generate.
   */
  static provider(config: DemoChildConfig) {
    return [
      { provide: DemoChildGenerator, useClass: DemoChildGenerator },
      { provide: DemoChildConfig, useValue: config },
    ];
  }
```

(4.) Use the `provider()` method when registering your service with the DemoDataModule
and set your config there at the same time:

```
DemoDataModule.forRoot([
  ...DemoChildGenerator.provider({count: 150}),
])
```

Note that the spread operator (the `...` in front of the call to `.provider()`) is required.
As the `provider()` method returns an array of providers, the `...` "flattens" that array
and simply makes all providers directly items of the primary array that is passed into `DemoDataModule.forRoot()`.
