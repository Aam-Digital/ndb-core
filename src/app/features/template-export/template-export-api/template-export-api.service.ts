import { Inject, Injectable } from "@angular/core";
import { FileService } from "../../file/file.service";
import { SafeUrl } from "@angular/platform-browser";
import { Entity } from "app/core/entity/model/entity";
import { Observable, of, throwError } from "rxjs";
import { EntityMapperService } from "../../../core/entity/entity-mapper/entity-mapper.service";
import { EntityRegistry } from "../../../core/entity/database-entity.decorator";
import { SyncStateSubject } from "../../../core/session/session-type";
import { HttpClient } from "@angular/common/http";
import { NotAvailableOfflineError } from "../../../core/session/not-available-offline.error";
import { NAVIGATOR_TOKEN } from "../../../utils/di-tokens";
import { switchMap } from "rxjs/operators";
import { TemplateExport } from "../template-export.entity";
import { Logging } from "../../../core/logging/logging.service";

/**
 * Format of API response body upon uploading a new template file.
 */
interface TemplateUploadResponseDto {
  templateId: string;
}

/**
 * Format of API request body to render a PDF from a template.
 * TemplateId is provided via URL path.
 */
interface TemplateRenderRequestDto {
  /**
   * target file type (e.g. "pdf")
   */
  convertTo: string;

  /**
   * The data used to fill placeholders in the template.
   */
  data: Object;
}

/**
 * Interact with the PDF Template Generation API that uses File Templates to generate custom pdf documents.
 */
@Injectable({
  providedIn: "root",
})
export class TemplateExportApiService extends FileService {
  readonly BACKEND_URL = "/query/api/v1/export/";

  constructor(
    entityMapper: EntityMapperService,
    entities: EntityRegistry,
    syncState: SyncStateSubject,
    @Inject(NAVIGATOR_TOKEN) private navigator: Navigator,
    private httpClient: HttpClient,
  ) {
    super(entityMapper, entities, syncState);
  }

  /*
  --- FileService methods ---
  */

  /**
   * Upload a new template file to the API.
   * @param file to be uploaded to the API as a template
   * @param entity
   * @param property
   * @return The template ID generated by the API
   */
  uploadFile(file: File, entity: Entity, property: string): Observable<string> {
    if (!this.navigator.onLine) {
      return throwError(() => new NotAvailableOfflineError("File Attachments"));
    }

    const formData = new FormData();
    formData.append("template", file, file.name);

    return this.httpClient.post(this.BACKEND_URL + "template", formData).pipe(
      switchMap(async (res: TemplateUploadResponseDto) => {
        // TODO: maybe store template filename + templateId (API) in entity, to show the user better meta-information?

        (entity as TemplateExport).templateId = res.templateId;
        await this.entityMapper.save(entity);
        return res.templateId;
      }),
    );
  }

  showFile(entity: Entity, property: string): void {
    // TODO: replace with actual implementation for PDF API
    throw new Error("Method not implemented.");
  }

  loadFile(entity: Entity, property: string): Observable<SafeUrl> {
    // should not be required for our use cases of the Template Export API
    throw new Error("Method not implemented.");
  }

  removeFile(entity: Entity, property: string): Observable<any> {
    // we do not do explicit file removal due to the design of the API
    Logging.debug("skipping file removal for Template Export API");
    return of(true);
  }
  removeAllFiles(entity: Entity): Observable<any> {
    Logging.debug("skipping file removal for Template Export API");
    return of(true);
  }

  /*
  --- PDF Generation API methods ---
  */

  /**
   * Generate a PDF applying actual data to an existing template.
   * @param templateEntityId The id of the TemplateExport entity (not the template ID of the PDF API)
   * @param data The data object (typically an entity) to be applied to the template
   * @return An array buffer of the generated PDF
   */
  generatePdfFromTemplate(
    templateEntityId: string,
    data: Object,
  ): Observable<SafeUrl> {
    return this.httpClient.post(
      this.BACKEND_URL + "render/" + templateEntityId,
      {
        convertTo: "pdf",
        data: data,
      } as TemplateRenderRequestDto,
      { responseType: "arraybuffer" },
    ); // TODO .pipe(switchMap(async (res: ArrayBuffer) => {
    // read header Content-Disposition to get filename
  }
}
