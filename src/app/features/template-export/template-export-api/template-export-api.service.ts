import { Inject, Injectable } from "@angular/core";
import { FileService } from "../../file/file.service";
import { SafeUrl } from "@angular/platform-browser";
import { Entity } from "app/core/entity/model/entity";
import { Observable, of, throwError } from "rxjs";
import { EntityMapperService } from "../../../core/entity/entity-mapper/entity-mapper.service";
import { EntityRegistry } from "../../../core/entity/database-entity.decorator";
import { SyncStateSubject } from "../../../core/session/session-type";
import { HttpResponse } from "@angular/common/http";
import { NotAvailableOfflineError } from "../../../core/session/not-available-offline.error";
import { NAVIGATOR_TOKEN } from "../../../utils/di-tokens";
import { switchMap } from "rxjs/operators";
import { TemplateExport } from "../template-export.entity";
import { Logging } from "../../../core/logging/logging.service";

/**
 * Format of API response body upon uploading a new template file.
 */
interface TemplateUploadResponseDto {
  templateId: string;
}

/**
 * Format of API request body to render a PDF from a template.
 * TemplateId is provided via URL path.
 */
interface TemplateRenderRequestDto {
  /**
   * target file type (e.g. "pdf")
   */
  convertTo: string;

  /**
   * The data used to fill placeholders in the template.
   */
  data: Object;
}

export interface TemplateExportResult {
  filename: string;
  file: ArrayBuffer;
}

/**
 * Interact with the PDF Template Generation API that uses File Templates to generate custom pdf documents.
 */
@Injectable({
  providedIn: "root",
})
export class TemplateExportApiService extends FileService {
  readonly BACKEND_URL = "/query/api/v1/export/";

  constructor(
    entityMapper: EntityMapperService,
    entities: EntityRegistry,
    syncState: SyncStateSubject,
    @Inject(NAVIGATOR_TOKEN) private navigator: Navigator,
  ) {
    super(entityMapper, entities, syncState);
  }

  /*
  --- FileService methods ---
  */

  /**
   * Upload a new template file to the API.
   * @param file to be uploaded to the API as a template
   * @param entity
   * @param property
   * @return The template ID generated by the API
   */
  uploadFile(
    file: File,
    entity: TemplateExport,
    property: string,
  ): Observable<string> {
    if (!this.navigator.onLine) {
      return throwError(() => new NotAvailableOfflineError("File Attachments"));
    }

    const formData = new FormData();
    formData.append("template", file, file.name);

    return this.httpClient.post(this.BACKEND_URL + "template", formData).pipe(
      switchMap(async (res: TemplateUploadResponseDto) => {
        entity.templateId = res.templateId;
        await this.entityMapper.save(entity);
        return res.templateId;
      }),
    );
  }

  protected override getShowFileUrl(
    entity: TemplateExport,
    property: string,
  ): string {
    // TODO: should we use the entityId here instead, to stay consistent?
    return this.BACKEND_URL + "template/" + entity.templateId;
  }

  loadFile(entity: Entity, property: string): Observable<SafeUrl> {
    // should not be required for our use cases of the Template Export API
    throw new Error("Method not implemented.");
  }

  removeFile(entity: Entity, property: string): Observable<any> {
    // we do not do explicit file removal due to the design of the API
    Logging.debug("skipping file removal for Template Export API");
    return of(true);
  }
  removeAllFiles(entity: Entity): Observable<any> {
    Logging.debug("skipping file removal for Template Export API");
    return of(true);
  }

  /*
  --- PDF Generation API methods ---
  */

  /**
   * Generate a PDF applying actual data to an existing template.
   * @param templateEntityId The id of the TemplateExport entity (not the template ID of the PDF API)
   * @param data The data object (typically an entity) to be applied to the template
   * @return An array buffer of the generated PDF
   */
  generatePdfFromTemplate(
    templateEntityId: string,
    data: Object,
  ): Observable<TemplateExportResult> {
    return this.httpClient
      .post(
        this.BACKEND_URL + "render/" + templateEntityId,
        {
          convertTo: "pdf",
          data: data,
        } as TemplateRenderRequestDto,
        { observe: "response", responseType: "arraybuffer" },
      )
      .pipe(
        switchMap(async (res: HttpResponse<ArrayBuffer>) => {
          // the API returns the filename in the Content-Disposition header as a URL-encoded string with special delimiters
          const filename = decodeURIComponent(
            res.headers.get("Content-Disposition"),
          ).match(/filename=_(.+)_/)[1];

          return {
            filename: filename,
            file: res.body,
          };
        }),
      );
  }
}
